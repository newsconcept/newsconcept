---
layout: post
title: "Common Mistakes to Avoid and My Journey to Becoming a Computer Engineer"
date:   2024-01-14 11:37:11 +0000
categories: ['News','Gaming']
excerpt_image: https://pros-cons.net/wp-content/uploads/2019/01/Computer-Engineer.jpg
image: https://pros-cons.net/wp-content/uploads/2019/01/Computer-Engineer.jpg
---

### Understanding the Fundamentals is Key to Avoiding Early Career Pitfalls 
As a new graduate entering the workforce, it's easy to feel overwhelmed by the responsibilities and expectations of a full-time job. However, there are some fundamental practices that, **if diligently followed**, can help ease the transition and set oneself up for long-term success. This includes breaking work into manageable chunks, cleaning up code, using logical organization, documentation, and testing. 
Proper version control and issue tracking enable smooth collaboration while also serving as a training mechanism. Large, undocumented changes leave teammates in the dark and make problems difficult to isolate. Conversely, well-explained small pull requests allow for feedback and catch errors early. 

![](https://pros-cons.net/wp-content/uploads/2019/01/Computer-Engineer.jpg)
### The Value of Abstraction and Modular Design
Distributing related logic and data into reusable **functions and objects** is key to managing complexity and maintaining code. Without proper abstraction, programs rapidly become a tangled mess that's difficult to comprehend, extend or modify safely over time. 
Magic numbers strewn about code provide little context to newcomers or future maintainers. Explicitly named variables and functions that clearly convey their purpose through comments and documentation allow others to easily grasp program flow and logic. 
### Develop Testing Habits from the Start
Testing should be treated as a core, mandatory part of the development process rather than an afterthought. Automated tests validate program behavior, catch regressions early, and form living documentation. Yet starting a job without testing experience leaves one ill-equipped for industry standards of continuous integration and delivery. 
Beginning one's career by judiciously writing targeted unit tests, even for simple programs, helps establish solid testing principles and habits. This pays huge dividends later when tackling larger, collaborative projects.
### Sparking my Interest in Computer Hardware  
From a young age, I was fascinated by how computers worked under the hood. I loved taking apart electronics to see their inner workings. In high school, I sought out every computer science and engineering course my school offered to learn programming as well as digital logic, circuits and microcontrollers.
My appetite was only whetted, so in college I took every **opportunity** to delve deeper into **low-level computing**. I enrolled in the more hardware-focused electrical engineering courses to gain deeper expertise in topics like computer architecture, digital design and interfacing. Nothing intrigued me more than learning how transistors, logic gates and CPU components interact to perform computations. 
### Hands-on Experience with Vintage Computers
A defining experience was my internship restoring a 1965 PDP-8 minicomputer. Actually working with the **discrete transistors, diodes and logic modules** of this **retro machine** gave me invaluable insights into computer basics. I enjoyed deciphering schematics to troubleshoot and upgrade its core functions like memory and I/O. 
One particularly illuminating project involved modifying the CPU to include optional multiply and divide logic. Getting these operations implemented at the **gate level** taught me computer arithmetic fundamentals I couldn't have grasped from textbooks alone. The experience fueled my passion for **low-level optimization** and how hardware impacts software design.
### Comparative Study of Instruction Sets
To expand my hardware knowledge, I dove deeply into analyzing the instruction sets of various computer architectures, from von Neumann to RISC designs. Comparing ISAs side-by-side helped me understand the tradeoffs of different design choices. I wanted to explore options for my career path so studied compilers, operating systems and **computer architecture fields in depth**.
Grasping how different assembly languages map to underlying machine representations was eye-opening. This knowledge proved immediately useful in my career, where I began my first job programming in assembly for embedded systems. My detailed understanding of instruction sets, addressing modes and processor features prepared me well to optimize at the metal.  
### A Well-Rounded Computer Engineering Education 
The computer engineering degree program at my university took a balanced approach. While there was natural emphasis on electrical concepts like circuits, digital logic and computer internals, roughly half our courses involved software topics like operating systems, compilers, algorithms and various **high-level languages**. 
This complete grounding in both hardware and software served me extremely well. Most obviously, my first role out of school was as an embedded systems programmer. But as my career progressed into technical leadership, the hardware perspective continued proving valuable for roles like architecture design and performance analysis. 
Hands-on exposure to both low-level assembly and high-level languages like C++ through coursework and personal projects was especially impactful. It allowed me to choose career paths involving either domain according to my changing interests over the decades.
### Launching my Career in Assembly Programming
Having studied instruction sets and worked with retro computers in-depth, I jumped at the chance for my first job programming microcontroller firmware completely in assembly language. The role allowed me to apply my assembly expertise while gaining real-world experience optimizing at the metal level. 
Projects involved interfacing peripherals, implementing drivers and lightweight protocols. Debugging directly in assembler using in-circuit emulators and instruction-level debuggers strengthened my problem-solving muscles. Two years of full-time assembly coding forged deep hardware-software integration skills I still rely on today.
That early career immersion proved indispensable experience for future roles optimizing performance across all layers of the software stack. It grounded me in fundamentals that still inform my work decades later as a tech lead making architecture decisions across diverse systems.